<!DOCTYPE html>
<html>
<head>
	<title>Test Path Generation</title>
	<link rel="stylesheet" type="text/css" href="../game.css">
</head>
<body>
	<ul>
		<li><button id='rewind'>Rewind</button></li>
		<li><button id='pause'>Pause</button></li>
		<li><button id='slow'>Slow</button></li>
		<li><button id='normal'>Normal</button></li>
		<li><button id='fast'>Fast Forward</button></li>
	</ul>

	<div id='w' class='g'>
		<canvas id='f' width=800 height=600></canvas>
	</div>
	<script src='../js/lib/jsfxr.min.js'></script>
	<script src="../js/init.js"></script>
	<script src="../js/const.js"></script>

	<script src="../js/levels/boss.js"></script>
	<script src="../js/levels/dialog.js"></script>
	<script src="../js/levels/splash.js"></script>
	<script src="../js/levels/wave.js"></script>

	<script src="../js/audio.js"></script>
	<script src="../js/dom.js"></script>
	<script src="../js/drawing.js"></script>
	<script src="../js/enemySpec.js"></script>
	<script src="../js/geometry.js"></script>
	<script src="../js/keyboard.js"></script>
	<script src="../js/levels.js"></script>
	<script src="../js/rand.js"></script>
	<script src="../js/shaders.js"></script>
	<script src="../js/math.js"></script>
	<script src="../js/path.js"></script>
  <script type="text/javascript">
  	$.assign($, {
		// timing data
		levelStartTime: null,
		levelGameTime: null,
		levelLastLoopTime: null,
		// enemy data
		levelEnemies: null,
		_activeEnemyIndexes: Array(100).fill(0),
		_activeEnemyCount: 0,
		// projectile data
		enemyProjectiles: null,
		_activeProjectileIndexes: Array(2000).fill(0),
		_activeProjectileCount: 0,
		// player data
		player: null,

		speedMultiplier: 1,

		_firstProjectileIdx: 0,
		_projectileShapeArray: [$.makeWebGLReady(['#ddd', 5, [5, 5]])],

		setTimeMultiplier: (tm) => {$.speedMultiplier = tm; return 1},

		renderEnemies: (gl, prog) => {
			for (let i = 0; i < $._activeEnemyCount; i++){
				let enemy = $.levelEnemies[$._activeEnemyIndexes[i]];
				let shapes = enemy[LevelShipIndex.SHAPES];
				let paths = enemy[LevelShipIndex.PATH_DATA];
				let pos = $.getPositionAtTime(paths, $.levelGameTime);

				$.drawShapesToCanvasGL(gl, prog, shapes, ...pos);
			}
		},

		renderEnemyProjectiles: (gl, prog, projectiles) => {
			for (let i = $._firstProjectileIdx; i < projectiles.length; i++){
				let [start, end, path] = projectiles[i];
				if (end !== undefined) {
					if ($._firstProjectileIdx === i) $._firstProjectileIdx++;
					continue
				};
				let elapsedTime = $.levelGameTime - start;
				let [x, y, xPerMs, yPerMs, startTime] = path;
				let newX = x + (elapsedTime * xPerMs);
				let newY = y + (elapsedTime * yPerMs)
				if (newX < 0 || newY < 0 || newY > GameConst.HEIGHT) projectiles[i][1] = $.levelGameTime;
				$.drawShapesToCanvasGL(gl, prog, $._projectileShapeArray, newX, newY)
			}
		},

		initializeLevel: (seed=1, numWaves=10, idealMsBetweenWaves=5000,
				idealProjectileWaves=3, idealProjectilesPerPath=3,
				idealProjectilePaths=4, idealTimeBetweenProjectiles=3000,
				projectileSpeed=200) => {
			let r = $.getRandomNumberGenerator(seed),
				i, waves = [], delay=0, path, enemy, projectilePattern, start, end, enemyR, timeBetweenProjectiles;

		  // generate the timings and paths for each wave of enemies
			for (i = 0; i < numWaves; i++) {
				// create the delay between this and the previous wave
				delay += $.randBetween(r, idealMsBetweenWaves * 0.75, idealMsBetweenWaves*1.25);
				// generate the path for the wave to follow
				path = $.generateRandomPath(r, delay);
				// the time at which the wave starts
				start = delay
				// the time at which the wave ends (for convenience's sake)
				end = delay + $.getTotalPathTime(path[0])
				// the enemy to use for the wave
				enemy = $.getRandomFromArray(r, $.enemySpec)
				enemyR = $.getRandomNumberGenerator(enemy[ObjectIndex.SEED]);
				enemyShapes = $.getRandomShapes(enemyR, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, enemy[ObjectIndex.SEED_SHAPE_STR])

				// the projectile pattern to use
				projectilePattern = $.generateProjectilePaths(
					enemyR,
					0, 0, 0, idealProjectileWaves-1, idealProjectileWaves+1,
				 idealProjectilesPerPath-1, idealProjectilesPerPath+1,
				 idealProjectilePaths-1, idealProjectilePaths+1, 2000, projectileSpeed)
				// time between volleys of projectiles
				timeBetweenProjectiles = $.floor($.randBetween(enemyR, idealTimeBetweenProjectiles*.75, idealTimeBetweenProjectiles*1.25))
				path.forEach(p => {
					let times = [];
					for (let j = start + timeBetweenProjectiles; j <= end; j += timeBetweenProjectiles) {
						let pos = $.getPositionAtTime(p, j);
						let projectilePaths = $.offsetProjectilePaths(
							projectilePattern,
							...pos,
							j
						).map(pp => [j, undefined, pp])
						times.push([j, projectilePaths]);
					}
					waves.push([start, end, undefined, enemyShapes, p, projectilePattern, times, 0])
				})
			}

			$.levelEnemies = waves;
		},

		initializeGame: () => {
			$.levelStartTime = $.levelLastLoopTime = Date.now();
			let r = $.getRandomNumberGenerator(1037);
			$.player = [
				$.getRandomShapes(r, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, 'm'),
				[0, 100],
				[0, 290, 235],
				100
			];
			$.levelGameTime = 0;
			$.enemyProjectiles = [];
		},

		updateEnemyStates: () => {
			let count = 0;

			for (let i = 0; i < $.levelEnemies.length; i++) {
				let wave = $.levelEnemies[i];

				if (wave[LevelShipIndex.KILL_TIME] !== undefined && wave[LevelShipIndex.KILL_TIME] > $.levelGameTime) {
					wave[LevelShipIndex.KILL_TIME] = undefined;
				}

				if (wave[LevelShipIndex.KILL_TIME] === undefined &&
						wave[LevelShipIndex.START_TIME] <= $.levelGameTime &&
						wave[LevelShipIndex.END_TIME] >= $.levelGameTime) {
					$._activeEnemyIndexes[count++] = i;
				}
			}

			$._activeEnemyCount = count;
		},

		updateProjectileStates: (elapsedTime) => {
			if (elapsedTime === 0) return;
			let i, idx = 0;

			if (elapsedTime < 0) {
				let shouldDelete = false;
				for (i = 0; shouldDelete === false && i < $.enemyProjectiles.length; i++) {
					let projectile = $.enemyProjectiles[i];
					if (projectile[1] && projectile[1] > $.levelGameTime) {
						if (i < $._firstProjectileIdx) $._firstProjectileIdx = i;
						projectile[1] = undefined;
					}
					if (projectile[0] > $.levelGameTime) shouldDelete = true;
				}
				if (shouldDelete) {
					$.enemyProjectiles = $.enemyProjectiles.filter(p => p[0] <= $.levelGameTime);
				}
			}

			for (i = 0; i < $._activeEnemyCount; i++) {
				let enemy = $.levelEnemies[$._activeEnemyIndexes[i]];

				if (elapsedTime < 0) {
					// reset the counters for new projectiles for each enemy
					while(enemy[LevelShipIndex.NEXT_PROJECTILE] > 0 &&
							enemy[LevelShipIndex.PROJECTILE_TIMES][enemy[LevelShipIndex.NEXT_PROJECTILE] - 1][0] > $.levelGameTime) {
						enemy[LevelShipIndex.NEXT_PROJECTILE]--;
					}
				} else if (elapsedTime > 0) {
					// spawn new waves of projectiles
					let nextTime = enemy[LevelShipIndex.NEXT_PROJECTILE];
					let path = enemy[LevelShipIndex.PROJECTILE_TIMES][nextTime];
					if (path && path[0] <= $.levelGameTime) {
						$.enemyProjectiles = $.enemyProjectiles.concat(
							path[1]
						)
						enemy[LevelShipIndex.NEXT_PROJECTILE]++;
					}
				}
			}
		}
	})

		$.getElementById('rewind').addEventListener('click', (e) => $.setTimeMultiplier(SpeedConst.REWIND) && e.preventDefault())
		$.getElementById('pause').addEventListener('click', (e) => $.setTimeMultiplier(SpeedConst.PAUSE) && e.preventDefault())
		$.getElementById('slow').addEventListener('click', (e) => $.setTimeMultiplier(SpeedConst.SLOW) && e.preventDefault())
		$.getElementById('normal').addEventListener('click', (e) => $.setTimeMultiplier(SpeedConst.NORMAL) && e.preventDefault())
		$.getElementById('fast').addEventListener('click', (e) => $.setTimeMultiplier(SpeedConst.FAST_FORWARD) && e.preventDefault())

		let gameLoop = () => {
			let currentTime = Date.now();
			let elapsedTime = (currentTime - $.levelLastLoopTime) * $.speedMultiplier;
			let shouldResumeNormal = false;
			$.levelLastLoopTime = currentTime;

			let lastGameTime = $.levelGameTime;
			$.levelGameTime += elapsedTime;

			if ($.levelGameTime < 0) {
				$.levelGameTime = 0;
				shouldResumeNormal = true;
			}

			// spawn enemies and update their positions
			$.updateEnemyStates();

			// spawn and update projectile positions
			$.updateProjectileStates(elapsedTime);

			// update player position (by player controls if non-negative, by replay if negative)

			// check for collision between player and enemy projectiles (if non-negative time)

			// update player health (if negative time, done automatically during collision tests normally)


			// initialize the canvas
			let canvas = $.getCanvas();
			let gl = $.get3DContext(canvas);
			$.clear3DCanvas(gl);

			// draw the background
			// $.renderStarfield(gl, gameTime, canvas.width, canvas.height);

			// render shapes
			let prog = $.prepareCanvasForShapes(gl, canvas.width, canvas.height);
			$.renderEnemies(gl, prog);
			$.renderEnemyProjectiles(gl, prog, $.enemyProjectiles);
			// renderPlayerProjectiles(gameTime);
			//
			gl.flush();

			if (shouldResumeNormal) {
				$.setTimeMultiplier(1);
			}
		}

		$.initializeGame()
		$.initializeLevel();
		//requestAnimationFrame(gameLoop)
		setInterval(gameLoop, 16)
	</script>
</body>
</html>
