<!DOCTYPE html>
<html>
<head>
	<title>Test Path Generation</title>
	<link rel="stylesheet" type="text/css" href="../game.css">
</head>
<body>
	<ul>
		<li><button id='rewind'>Rewind</button></li>
		<li><button id='pause'>Pause</button></li>
		<li><button id='slow'>Slow</button></li>
		<li><button id='normal'>Normal</button></li>
		<li><button id='fast'>Fast Forward</button></li>
	</ul>

	<div id='w' class='g'>
		<canvas id='f' width=800 height=600></canvas>
	</div>
	<script src='../js/lib/jsfxr.min.js'></script>
	<script src="../js/init.js"></script>
	<script src="../js/const.js"></script>

	<script src="../js/levels/boss.js"></script>
	<script src="../js/levels/dialog.js"></script>
	<script src="../js/levels/splash.js"></script>
	<script src="../js/levels/wave.js"></script>

	<script src="../js/audio.js"></script>
	<script src="../js/dom.js"></script>
	<script src="../js/drawing.js"></script>
	<script src="../js/enemySpec.js"></script>
	<script src="../js/geometry.js"></script>
	<script src="../js/keyboard.js"></script>
	<script src="../js/levels.js"></script>
	<script src="../js/rand.js"></script>
	<script src="../js/shaders.js"></script>
	<script src="../js/math.js"></script>
	<script src="../js/path.js"></script>
  <script type="text/javascript">
		let startTime = null;
		let gameTime = null;
		let lastTime = null;
		let timeMultiplier = 1;
		let levelWaves;
		let player;
		let canvas = $.getElementById('f');

		setTimeMultiplier = (tm) => {timeMultiplier = tm; return 1}

		$.getElementById('rewind').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.REWIND) && e.preventDefault())
		$.getElementById('pause').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.PAUSE) && e.preventDefault())
		$.getElementById('slow').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.SLOW) && e.preventDefault())
		$.getElementById('normal').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.NORMAL) && e.preventDefault())
		$.getElementById('fast').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.FAST_FORWARD) && e.preventDefault())

		let clearCanvas = () => {

		};

		let renderBackground = (gameTime) => {

		};

		let renderPlayer = (gameTime) => {

		};

		let renderEnemies = (gl, prog, gameTime, enemies) => {
			for (let i = 0; i < enemies.length; i++){
				let enemy = enemies[i];
				let shapes = enemy[LevelShipIndex.SHAPES];
				let paths = enemy[LevelShipIndex.PATH_DATA];
				let pos = $.getPositionAtTime(paths, gameTime);

				$.drawShapesToCanvasGL(gl, prog, shapes, ...pos);
			}
		};

		let renderPlayerProjectiles = (gameTime) => {

		};

		let renderEnemyProjectiles = (gameTime) => {

		};

		let updateAndRetrieveEnemies = (gameTime, elapsedTime) => {
			let activeEnemies = [];

			for (let i = 0; i < levelWaves.length; i++) {
				let wave = levelWaves[i];

				if (wave[LevelShipIndex.KILL_TIME] !== undefined && wave[LevelShipIndex.KILL_TIME] > gameTime) {
					wave[LevelShipIndex.KILL_TIME] = undefined;
				}

				if (wave[LevelShipIndex.KILL_TIME] === undefined &&
						wave[LevelShipIndex.START_TIME] <= gameTime &&
						wave[LevelShipIndex.END_TIME] >= gameTime) {
					activeEnemies.push(wave);
				}
			}
			return activeEnemies;
		};

		let initGame = () => {
			startTime = lastTime = Date.now();
			let r = $.getRandomNumberGenerator(1037);
			player = [
				$.getRandomShapes(r, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, 'm'),
				[0, 100],
				[0, 290, 235],
				100
			];
			gameTime = 0;
		}

		let generateLevel = (seed=1, numWaves=10, idealMsBetweenWaves=5000,
				idealProjectileWaves=3, idealProjectilesPerPath=3,
				idealProjectilePaths=4, idealTimeBetweenProjectiles=3000,
				projectileSpeed=200) => {
			let r = $.getRandomNumberGenerator(seed),
				i, waves = [], delay=0, path, enemy, projectilePattern, start, end, enemyR, timeBetweenProjectiles;

		  // generate the timings and paths for each wave of enemies
			for (i = 0; i < numWaves; i++) {
				// create the delay between this and the previous wave
				delay += $.randBetween(r, idealMsBetweenWaves * 0.75, idealMsBetweenWaves*1.25);
				// generate the path for the wave to follow
				path = $.generateRandomPath(r, delay);
				// the time at which the wave starts
				start = delay
				// the time at which the wave ends (for convenience's sake)
				end = delay + $.getTotalPathTime(path[0])
				// the enemy to use for the wave
				enemy = $.getRandomFromArray(r, $.enemySpec)
				enemyR = $.getRandomNumberGenerator(enemy[ObjectIndex.SEED]);
				enemyShapes = $.getRandomShapes(enemyR, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, enemy[ObjectIndex.SEED_SHAPE_STR])

				// the projectile pattern to use
				projectilePattern = $.generateProjectilePaths(
					enemyR,
					0, 0, 0, idealProjectileWaves-1, idealProjectileWaves+1,
				 idealProjectilesPerPath-1, idealProjectilesPerPath+1,
				 idealProjectilePaths-1, idealProjectilePaths+1, 2000, projectileSpeed)
				// time between volleys of projectiles
				timeBetweenProjectiles = $.floor($.randBetween(enemyR, idealTimeBetweenProjectiles*.75, idealTimeBetweenProjectiles*1.25))
				path.forEach(p => {
					waves.push([start, end, undefined, enemyShapes, p, projectilePattern, timeBetweenProjectiles])
				})
			}

			levelWaves = waves;
		};

		let gameLoop = () => {
			let currentTime = Date.now();
			let elapsedTime = currentTime - lastTime;
			let shouldResumeNormal = false;
			let enemies;
			lastTime = currentTime;

			let lastGameTime = gameTime;
			gameTime += elapsedTime * timeMultiplier;

			if (gameTime < 0) {
				gameTime = 0;
				shouldResumeNormal = true;
			}

			enemies = updateAndRetrieveEnemies(gameTime);
			//
			// if (timeMultiplier < 0) {
			// 	// time rewound
			// 	unspawnProjectiles(gameTime, lastGameTime);
			// 	restoreHealth(gameTime);
			// 	restorePlayerPosition(gameTime);
			//
			// } else if (timeMultiplier > 0) {
			// 	// time moving, need to spawn enemies
			// 	spawnProjectiles(gameTime, lastGameTime);
			// 	updatePlayerPosition(gameTime, elapsedTime);
			// }
			//
			// if (timeMultiplier !== 0) {
			// 	// need to reposition according to current time
			// 	moveEnemies(gameTime);
			// 	moveProjectiles(gameTime);
			// }
			//
			// if (timeMultiplier >= 0) {
			// 	// time isn't rewound, check for collisions
			// 	checkPlayerCollisions();
			// }
			//
			// if (timeMultiplier > 0) {
			// 	checkEnemyCollisions();
			// }


			// initialize the canvas
			let gl = $.get3DContext(canvas);
			$.clear3DCanvas(gl);

			// draw the background
			$.renderStarfield(gl, gameTime, canvas.width, canvas.height);

			// render shapes
			let prog = $.prepareCanvasForShapes(gl, canvas.width, canvas.height);
			renderEnemies(gl, prog, gameTime, enemies);
			// renderPlayerProjectiles(gameTime);
			// renderEnemyProjectiles(gameTime);

			if (shouldResumeNormal) {
				setTimeMultiplier(1);
			}
		}

		initGame()
		generateLevel();
		//requestAnimationFrame(gameLoop)
		setInterval(gameLoop, 16)
	</script>
</body>
</html>
