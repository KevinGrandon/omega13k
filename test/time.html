<!DOCTYPE html>
<html>
<head>
	<title>Test Path Generation</title>
	<link rel="stylesheet" type="text/css" href="../game.css">
</head>
<body>
	<ul>
		<li><button id='rewind'>Rewind</button></li>
		<li><button id='pause'>Pause</button></li>
		<li><button id='slow'>Slow</button></li>
		<li><button id='normal'>Normal</button></li>
		<li><button id='fast'>Fast Forward</button></li>
	</ul>

	<div id='w' class='g'>
		<canvas id='f' width=800 height=600></canvas>
	</div>
	<script src='../js/lib/jsfxr.min.js'></script>
	<script src="../js/init.js"></script>
	<script src="../js/const.js"></script>

	<script src="../js/levels/boss.js"></script>
	<script src="../js/levels/dialog.js"></script>
	<script src="../js/levels/splash.js"></script>
	<script src="../js/levels/wave.js"></script>

	<script src="../js/audio.js"></script>
	<script src="../js/dom.js"></script>
	<script src="../js/drawing.js"></script>
	<script src="../js/enemySpec.js"></script>
	<script src="../js/geometry.js"></script>
	<script src="../js/keyboard.js"></script>
	<script src="../js/levels.js"></script>
	<script src="../js/rand.js"></script>
	<script src="../js/shaders.js"></script>
	<script src="../js/math.js"></script>
	<script src="../js/path.js"></script>
  <script type="text/javascript">
		let startTime = null;
		let gameTime = null;
		let lastTime = null;
		let timeMultiplier = 1;
		let levelWaves;
		let enemyProjectiles;
		let firstProjectileIdx = 0;
		let player;
		let canvas = $.getElementById('f');
		let projectileShapeArray = [$.makeWebGLReady(['#ddd', 5, [5, 5]])]

		setTimeMultiplier = (tm) => {timeMultiplier = tm; return 1}

		$.getElementById('rewind').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.REWIND) && e.preventDefault())
		$.getElementById('pause').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.PAUSE) && e.preventDefault())
		$.getElementById('slow').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.SLOW) && e.preventDefault())
		$.getElementById('normal').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.NORMAL) && e.preventDefault())
		$.getElementById('fast').addEventListener('click', (e) => setTimeMultiplier(SpeedConst.FAST_FORWARD) && e.preventDefault())

		let renderEnemies = (gl, prog, gameTime, enemies) => {
			for (let i = 0; i < enemies.length; i++){
				let enemy = enemies[i];
				let shapes = enemy[LevelShipIndex.SHAPES];
				let paths = enemy[LevelShipIndex.PATH_DATA];
				let pos = $.getPositionAtTime(paths, gameTime);

				$.drawShapesToCanvasGL(gl, prog, shapes, ...pos);
			}
		};

		let renderEnemyProjectiles = (gl, prog, gameTime, projectiles) => {
			for (let i = firstProjectileIdx; i < projectiles.length; i++){
				let [start, end, path] = projectiles[i];
				if (end !== undefined) {
					if (firstProjectileIdx === i) firstProjectileIdx++;
					continue
				};
				let elapsedTime = gameTime - start;
				let [x, y, xPerMs, yPerMs, startTime] = path;
				let newX = x + (elapsedTime * xPerMs);
				let newY = y + (elapsedTime * yPerMs)
				if (newX < 0 || newY < 0 || newY > GameConst.HEIGHT) projectiles[i][1] = gameTime;
				$.drawShapesToCanvasGL(gl, prog, projectileShapeArray, newX, newY)
			}
		};

		let updateAndRetrieveEnemyProjectiles = (gameTime, elapsedTime, enemies) => {
			if (elapsedTime === 0) return;
			let i;

			if (elapsedTime < 0) {
				let shouldDelete = false;
				for (i = 0; shouldDelete === false && i < enemyProjectiles.length; i++) {
					let projectile = enemyProjectiles[i];
					if (projectile[1] && projectile[1] > gameTime) {
						if (i < firstProjectileIdx) firstProjectileIdx = i;
						projectile[1] = undefined;
					}
					if (projectile[0] > gameTime) shouldDelete = true;
				}
				if (shouldDelete) {
					enemyProjectiles = enemyProjectiles.filter(p => p[0] <= gameTime);
				}
			}

			for (i = 0; i < enemies.length; i++) {
				let enemy = enemies[i];

				if (elapsedTime < 0) {
					// reset the counters for new projectiles for each enemy
					while(enemy[LevelShipIndex.NEXT_PROJECTILE] > 0 &&
							enemy[LevelShipIndex.PROJECTILE_TIMES][enemy[LevelShipIndex.NEXT_PROJECTILE] - 1][0] > gameTime) {
						enemy[LevelShipIndex.NEXT_PROJECTILE]--;
					}
				} else if (elapsedTime > 0) {
					// spawn new waves of projectiles
					let nextTime = enemy[LevelShipIndex.NEXT_PROJECTILE];
					let path = enemy[LevelShipIndex.PROJECTILE_TIMES][nextTime];
					if (path && path[0] <= gameTime) {
						enemyProjectiles = enemyProjectiles.concat(
							$.offsetProjectilePaths(
								enemy[LevelShipIndex.PROJECTILE_PATH],
								path[1],
								path[2],
								path[0]
							).map(p => [path[0], undefined, p])
						)
						enemy[LevelShipIndex.NEXT_PROJECTILE]++;
					}
				}
			}
		};

		let updateAndRetrieveEnemies = (gameTime) => {
			let activeEnemies = [];

			for (let i = 0; i < levelWaves.length; i++) {
				let wave = levelWaves[i];

				if (wave[LevelShipIndex.KILL_TIME] !== undefined && wave[LevelShipIndex.KILL_TIME] > gameTime) {
					wave[LevelShipIndex.KILL_TIME] = undefined;
				}

				if (wave[LevelShipIndex.KILL_TIME] === undefined &&
						wave[LevelShipIndex.START_TIME] <= gameTime &&
						wave[LevelShipIndex.END_TIME] >= gameTime) {
					activeEnemies.push(wave);
				}
			}
			return activeEnemies;
		};

		let initGame = () => {
			startTime = lastTime = Date.now();
			let r = $.getRandomNumberGenerator(1037);
			player = [
				$.getRandomShapes(r, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, 'm'),
				[0, 100],
				[0, 290, 235],
				100
			];
			gameTime = 0;
			enemyProjectiles = [];
		}

		let generateLevel = (seed=1, numWaves=10, idealMsBetweenWaves=5000,
				idealProjectileWaves=3, idealProjectilesPerPath=3,
				idealProjectilePaths=4, idealTimeBetweenProjectiles=3000,
				projectileSpeed=200) => {
			let r = $.getRandomNumberGenerator(seed),
				i, waves = [], delay=0, path, enemy, projectilePattern, start, end, enemyR, timeBetweenProjectiles;

		  // generate the timings and paths for each wave of enemies
			for (i = 0; i < numWaves; i++) {
				// create the delay between this and the previous wave
				delay += $.randBetween(r, idealMsBetweenWaves * 0.75, idealMsBetweenWaves*1.25);
				// generate the path for the wave to follow
				path = $.generateRandomPath(r, delay);
				// the time at which the wave starts
				start = delay
				// the time at which the wave ends (for convenience's sake)
				end = delay + $.getTotalPathTime(path[0])
				// the enemy to use for the wave
				enemy = $.getRandomFromArray(r, $.enemySpec)
				enemyR = $.getRandomNumberGenerator(enemy[ObjectIndex.SEED]);
				enemyShapes = $.getRandomShapes(enemyR, GameConst.SHIP_WIDTH, GameConst.SHIP_HEIGHT, enemy[ObjectIndex.SEED_SHAPE_STR])

				// the projectile pattern to use
				projectilePattern = $.generateProjectilePaths(
					enemyR,
					0, 0, 0, idealProjectileWaves-1, idealProjectileWaves+1,
				 idealProjectilesPerPath-1, idealProjectilesPerPath+1,
				 idealProjectilePaths-1, idealProjectilePaths+1, 2000, projectileSpeed)
				// time between volleys of projectiles
				timeBetweenProjectiles = $.floor($.randBetween(enemyR, idealTimeBetweenProjectiles*.75, idealTimeBetweenProjectiles*1.25))
				path.forEach(p => {
					let times = [];
					for (let j = start + timeBetweenProjectiles; j <= end; j += timeBetweenProjectiles) {
						times.push([j, ...$.getPositionAtTime(p, j)]);
					}
					waves.push([start, end, undefined, enemyShapes, p, projectilePattern, times, 0])
				})
			}

			levelWaves = waves;
		};

		let gameLoop = () => {
			let currentTime = Date.now();
			let elapsedTime = (currentTime - lastTime) * timeMultiplier;
			let shouldResumeNormal = false;
			let enemies;
			lastTime = currentTime;

			let lastGameTime = gameTime;
			gameTime += elapsedTime;

			if (gameTime < 0) {
				gameTime = 0;
				shouldResumeNormal = true;
			}

			enemies = updateAndRetrieveEnemies(gameTime);
			updateAndRetrieveEnemyProjectiles(gameTime, elapsedTime, enemies);
			//
			// if (timeMultiplier < 0) {
			// 	// time rewound
			// 	unspawnProjectiles(gameTime, lastGameTime);
			// 	restoreHealth(gameTime);
			// 	restorePlayerPosition(gameTime);
			//
			// } else if (timeMultiplier > 0) {
			// 	// time moving, need to spawn enemies
			// 	spawnProjectiles(gameTime, lastGameTime);
			// 	updatePlayerPosition(gameTime, elapsedTime);
			// }
			//
			// if (timeMultiplier !== 0) {
			// 	// need to reposition according to current time
			// 	moveEnemies(gameTime);
			// 	moveProjectiles(gameTime);
			// }
			//
			// if (timeMultiplier >= 0) {
			// 	// time isn't rewound, check for collisions
			// 	checkPlayerCollisions();
			// }
			//
			// if (timeMultiplier > 0) {
			// 	checkEnemyCollisions();
			// }


			// initialize the canvas
			let gl = $.get3DContext(canvas);
			$.clear3DCanvas(gl);

			// draw the background
			$.renderStarfield(gl, gameTime, canvas.width, canvas.height);

			// render shapes
			let prog = $.prepareCanvasForShapes(gl, canvas.width, canvas.height);
			renderEnemies(gl, prog, gameTime, enemies);
			renderEnemyProjectiles(gl, prog, gameTime, enemyProjectiles);
			// renderPlayerProjectiles(gameTime);
			//

			if (shouldResumeNormal) {
				setTimeMultiplier(1);
			}
		}

		initGame()
		generateLevel();
		//requestAnimationFrame(gameLoop)
		setInterval(gameLoop, 16)
	</script>
</body>
</html>
